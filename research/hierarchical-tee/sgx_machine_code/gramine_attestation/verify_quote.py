#!/usr/bin/env python3
"""
SGX Quote Verification Script

This script verifies an SGX DCAP quote generated by the Gramine attestation demo.
It parses the quote structure and displays key information for verification.

For full cryptographic verification, use the Intel DCAP libraries or
Gramine's RA-TLS verification functions.

Usage:
    python3 verify_quote.py quote.bin
"""

import sys
import struct
import hashlib
from pathlib import Path


# Quote header version constants
QUOTE_VERSION_3 = 3

# Attestation key types
ATT_KEY_TYPE_ECDSA_P256 = 2
ATT_KEY_TYPE_ECDSA_P384 = 3


def read_quote_file(filepath: str) -> bytes:
    """Read the binary quote file."""
    path = Path(filepath)
    if not path.exists():
        print(f"Error: Quote file not found: {filepath}")
        sys.exit(1)
    
    return path.read_bytes()


def parse_quote_header(quote: bytes) -> dict:
    """
    Parse the SGX DCAP quote header.
    
    Quote v3 Header (48 bytes):
    - Offset 0-1:   Version (uint16)
    - Offset 2-3:   Attestation Key Type (uint16)
    - Offset 4-7:   Reserved (4 bytes)
    - Offset 8-9:   QE SVN (uint16)
    - Offset 10-11: PCE SVN (uint16)
    - Offset 12-27: QE Vendor ID (16 bytes UUID)
    - Offset 28-47: User Data (20 bytes)
    """
    if len(quote) < 48:
        raise ValueError(f"Quote too short: {len(quote)} bytes (minimum 48)")
    
    header = {}
    header['version'] = struct.unpack("<H", quote[0:2])[0]
    header['att_key_type'] = struct.unpack("<H", quote[2:4])[0]
    header['reserved'] = quote[4:8]
    header['qe_svn'] = struct.unpack("<H", quote[8:10])[0]
    header['pce_svn'] = struct.unpack("<H", quote[10:12])[0]
    header['qe_vendor_id'] = quote[12:28]
    header['user_data'] = quote[28:48]
    
    return header


def parse_report_body(quote: bytes) -> dict:
    """
    Parse the SGX Report Body from the quote.
    
    Report Body starts at offset 48 (after header) and is 384 bytes.
    
    Key fields:
    - Offset 0-15:   CPU SVN (16 bytes)
    - Offset 16-19:  Misc Select (4 bytes)
    - Offset 20-47:  Reserved1 (28 bytes)
    - Offset 48-63:  Attributes (16 bytes)
    - Offset 64-95:  MRENCLAVE (32 bytes)
    - Offset 96-127: Reserved2 (32 bytes)
    - Offset 128-159: MRSIGNER (32 bytes)
    - Offset 160-255: Reserved3 (96 bytes)
    - Offset 256-257: ISV PROD ID (2 bytes)
    - Offset 258-259: ISV SVN (2 bytes)
    - Offset 260-319: Reserved4 (60 bytes)
    - Offset 320-383: Report Data (64 bytes) <- User Report Data
    """
    if len(quote) < 48 + 384:
        raise ValueError(f"Quote too short for report body: {len(quote)} bytes")
    
    report = quote[48:48+384]
    body = {}
    
    body['cpu_svn'] = report[0:16]
    body['misc_select'] = struct.unpack("<I", report[16:20])[0]
    body['attributes'] = report[48:64]
    body['mrenclave'] = report[64:96]
    body['mrsigner'] = report[128:160]
    body['isv_prod_id'] = struct.unpack("<H", report[256:258])[0]
    body['isv_svn'] = struct.unpack("<H", report[258:260])[0]
    body['report_data'] = report[320:384]
    
    # Parse attributes
    attr_flags = struct.unpack("<Q", body['attributes'][0:8])[0]
    attr_xfrm = struct.unpack("<Q", body['attributes'][8:16])[0]
    body['attr_flags'] = attr_flags
    body['attr_xfrm'] = attr_xfrm
    body['attr_debug'] = bool(attr_flags & 0x02)
    body['attr_mode64bit'] = bool(attr_flags & 0x04)
    
    return body


def format_bytes_hex(data: bytes, max_len: int = 32) -> str:
    """Format bytes as hex string, truncating if needed."""
    hex_str = data.hex()
    if len(data) > max_len:
        return hex_str[:max_len*2] + "..."
    return hex_str


def format_uuid(data: bytes) -> str:
    """Format 16 bytes as UUID string."""
    if len(data) != 16:
        return data.hex()
    return f"{data[0:4].hex()}-{data[4:6].hex()}-{data[6:8].hex()}-{data[8:10].hex()}-{data[10:16].hex()}"


def print_quote_info(header: dict, body: dict, quote_size: int):
    """Print parsed quote information in a readable format."""
    print("=" * 70)
    print("SGX DCAP Quote Analysis")
    print("=" * 70)
    print()
    
    # Header info
    print("Quote Header")
    print("-" * 70)
    print(f"  Version:           {header['version']}")
    
    att_key_names = {
        ATT_KEY_TYPE_ECDSA_P256: "ECDSA-256-P256",
        ATT_KEY_TYPE_ECDSA_P384: "ECDSA-384-P384",
    }
    att_key_name = att_key_names.get(header['att_key_type'], "Unknown")
    print(f"  Att Key Type:      {header['att_key_type']} ({att_key_name})")
    print(f"  QE SVN:            {header['qe_svn']}")
    print(f"  PCE SVN:           {header['pce_svn']}")
    print(f"  QE Vendor ID:      {format_uuid(header['qe_vendor_id'])}")
    print(f"  Total Quote Size:  {quote_size} bytes")
    print()
    
    # Report body info
    print("Report Body (Enclave Measurements)")
    print("-" * 70)
    print(f"  MRENCLAVE:         {body['mrenclave'].hex()}")
    print(f"  MRSIGNER:          {body['mrsigner'].hex()}")
    print(f"  ISV Prod ID:       {body['isv_prod_id']}")
    print(f"  ISV SVN:           {body['isv_svn']}")
    print()
    
    # Attributes
    print("Enclave Attributes")
    print("-" * 70)
    print(f"  DEBUG:             {body['attr_debug']} {'⚠️  (INSECURE!)' if body['attr_debug'] else '✓'}")
    print(f"  MODE64BIT:         {body['attr_mode64bit']}")
    print(f"  Flags (raw):       0x{body['attr_flags']:016x}")
    print(f"  XFRM (raw):        0x{body['attr_xfrm']:016x}")
    print()
    
    # User report data
    print("User Report Data (64 bytes)")
    print("-" * 70)
    print(f"  Hex:    {body['report_data'][:32].hex()}")
    print(f"          {body['report_data'][32:].hex()}")
    
    # Try to decode as string
    try:
        decoded = body['report_data'].rstrip(b'\x00').decode('utf-8')
        print(f"  String: {decoded}")
    except:
        print("  String: (not valid UTF-8)")
    print()
    
    # Security warnings
    print("Security Assessment")
    print("-" * 70)
    if body['attr_debug']:
        print("  ⚠️  WARNING: Debug enclave - NOT suitable for production!")
    else:
        print("  ✓ Production mode enclave")
    
    if header['version'] < 3:
        print("  ⚠️  WARNING: Quote version < 3 may have limited support")
    else:
        print("  ✓ Quote version 3 (DCAP)")
    
    print()


def compare_with_expected(body: dict, expected_mrenclave: str = None, 
                          expected_mrsigner: str = None):
    """Compare quote measurements with expected values."""
    print("Verification Against Expected Values")
    print("-" * 70)
    
    if expected_mrenclave:
        expected = bytes.fromhex(expected_mrenclave)
        if body['mrenclave'] == expected:
            print(f"  ✓ MRENCLAVE matches expected value")
        else:
            print(f"  ✗ MRENCLAVE mismatch!")
            print(f"    Expected: {expected_mrenclave}")
            print(f"    Got:      {body['mrenclave'].hex()}")
    else:
        print("  - MRENCLAVE: No expected value provided")
    
    if expected_mrsigner:
        expected = bytes.fromhex(expected_mrsigner)
        if body['mrsigner'] == expected:
            print(f"  ✓ MRSIGNER matches expected value")
        else:
            print(f"  ✗ MRSIGNER mismatch!")
            print(f"    Expected: {expected_mrsigner}")
            print(f"    Got:      {body['mrsigner'].hex()}")
    else:
        print("  - MRSIGNER: No expected value provided")
    
    print()


def main():
    """Main verification flow."""
    if len(sys.argv) < 2:
        print("Usage: python3 verify_quote.py <quote_file> [expected_mrenclave] [expected_mrsigner]")
        print("\nExample:")
        print("  python3 verify_quote.py quote.bin")
        print("  python3 verify_quote.py quote.bin abc123... def456...")
        sys.exit(1)
    
    quote_file = sys.argv[1]
    expected_mrenclave = sys.argv[2] if len(sys.argv) > 2 else None
    expected_mrsigner = sys.argv[3] if len(sys.argv) > 3 else None
    
    # Read and parse quote
    print(f"\nReading quote from: {quote_file}\n")
    quote = read_quote_file(quote_file)
    
    try:
        header = parse_quote_header(quote)
        body = parse_report_body(quote)
    except ValueError as e:
        print(f"Error parsing quote: {e}")
        sys.exit(1)
    
    # Display info
    print_quote_info(header, body, len(quote))
    
    # Compare with expected values if provided
    if expected_mrenclave or expected_mrsigner:
        compare_with_expected(body, expected_mrenclave, expected_mrsigner)
    
    print("=" * 70)
    print("Note: This is a structural verification only.")
    print("For cryptographic verification, use Intel DCAP libraries or")
    print("gramine-sgx-quote-view with validation enabled.")
    print("=" * 70)


if __name__ == "__main__":
    main()
